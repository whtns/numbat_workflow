---
title: "H. Singh Mouse Datasets"
author: "Mitali Singh"
output: html_document
---

```{r, echo = F}
knitr::opts_chunk$set(echo = F, message = F)
```


# load required libraries 

```{r}
library(monocle)
library(SingleCellExperiment)
library(tidyverse)
library(glue)
library(scran)
library(scater)
library(rprojroot)
proj_dir = find_root_file(criterion = ".Rhistory")
```

# Load functions

```{r}

append_expids <- function(txi, tpm_meta, expid){
	
	
	tpm_ids <- colnames(txi$counts)
	meta_ids <- tpm_meta[[1]]
	
	# tpm_ids <- str_replace_all(tpm_ids, "[[:alpha:]]", "")
	# meta_ids <- str_replace_all(meta_ids, "[[:alpha:]]", "")
	
	tpm_ids <- as.character(glue::glue("{expid}_{tpm_ids}"))
	meta_ids <- as.character(glue::glue("{expid}_{meta_ids}"))
	
	colnames(txi$counts) <- tpm_ids
	colnames(txi$abundance) <- tpm_ids
	colnames(txi$length) <- tpm_ids
	tpm_meta[,1] <- meta_ids
	
	return(list("txi" = txi, "colData" = tpm_meta))
}


#Make SCE from census counts-------------------------------------------
sce_from_tibbles <- function(exp_list, census_counts=NULL, expids){
	
	txi <- exp_list$txi
	colData = exp_list$colData
  
  featuredata <- data.frame(rownames(txi$counts))
  rownames(featuredata) <- featuredata[,1]
  
  txi$counts <- as.matrix(txi$counts)
  
  if (!is.null(census_counts)){

    census_counts <- tibble::column_to_rownames(census_counts, colnames(census_counts)[1]) %>% 
      as.matrix()
    
    # reformat counts and coldata sample names to match names of census_counts
    all_samples <- str_split_fixed(str = colnames(census_counts), pattern = "_", n = 2)[,2]
    
    match_samples <- match(all_samples, colnames(counts))
    
    counts <- counts[,match_samples]
    colnames(counts) <- colnames(census_counts)
    
    colData <- data.frame(colData)
    rownames(colData) <- colData[,1]
    colData <- colData[colnames(counts),]
    
    # all(str_split_fixed(colnames(census_counts), pattern = "_", n=2)[,2] == colnames(new_counts))
    
    # subset counts by census to remove features dropped during conversion
    bioids <- intersect(rownames(counts), rownames(census_counts))
     counts <- counts[bioids,]
     census_counts <- census_counts[bioids,]
     featuredata <- featuredata[rownames(counts),,drop = F]
     
  
    sumexp <- SummarizedExperiment(assays=list(counts=counts, census_counts=census_counts), colData=colData, rowData=featuredata)
  
      
  } else {
    
       
    colData <- data.frame(colData)
    rownames(colData) <- colData[,1]
    colData <- colData[colnames(txi$counts),]
    
    sumexp <- SummarizedExperiment(assays=list(counts=txi$counts, abundance = txi$abundance, length = txi$length), colData=colData, rowData=featuredata)

    
  }
  
   
  # filter out cells not in comparison
  sce <- sce <- as(sumexp, "SingleCellExperiment")
  
  return(sce)
}

append_census_counts <- function(sce, census_counts){
  
  sce <- sce[,colnames(census_counts)]
  
  counts <- counts(sce)
  
  cd <- colData(sce) %>% 
  	as.data.frame()
  
  featuredata <- data.frame(rownames(counts))
  rownames(featuredata) <- featuredata[,1]
  
  # cd <- cd[colnames(census_counts),]
  
    # subset counts by census to remove features and samples dropped during conversion
  bioids <- intersect(rownames(counts), rownames(census_counts))
  counts <- counts[bioids,]
  census_counts <- census_counts[bioids,]
  featuredata <- featuredata[rownames(counts),,drop = F]
  
	# 
  sumexp <- SummarizedExperiment(assays=c(assays(sce), list(census_counts = census_counts)), colData=cd, rowData=featuredata)
  
  # filter out cells not in comparison
  sce <- sce <- as(sumexp, "SingleCellExperiment")
  
  return(sce)
  
}

run_census <- function(sce){
	# 
	
	# create new celldataset
	pd <- new("AnnotatedDataFrame", data=data.frame(colData(sce)))
	fd <- new("AnnotatedDataFrame", data=data.frame(rowData(sce)))
	
	
	HSMM <- newCellDataSet(assays(sce)[["abundance"]],
												 phenoData = pd,
												 featureData = fd,
												 lowerDetectionLimit=0.1,
												 expressionFamily=tobit(Lower=0.1))
	
	# saveRDS(HSMM, HSMM_path)
	
	OnlyZeros = (colSums(Biobase::exprs(HSMM))==0)
	paste(sum(OnlyZeros), "cells have zero reads in total")
	
	Valid = which(!OnlyZeros)
	
	HSMM <- HSMM[,Valid]
	
	rpc_matrix <- monocle::relative2abs(HSMM, method = "num_genes")

	pd <- pd[Valid,]
	
	# Now, make a new CellDataSet using the RNA counts
	HSMM <- newCellDataSet(as(rpc_matrix, "sparseMatrix"),
												 phenoData = pd,
												 featureData = fd,
												 lowerDetectionLimit=1,
												 expressionFamily=negbinomial.size())
	
	
	# HSMM <- estimateSizeFactors(HSMM)
	# HSMM <- estimateDispersions(HSMM)
	
	
	#print output of census to csv prior to monocle workflow
	
	
	return(as.matrix(Biobase::exprs(HSMM)))

}

prep_batches <- function(sce){
  # 

  sce <- calculateQCMetrics(sce, compact=TRUE)
  QC <- sce$scater_qc
  low.lib <- isOutlier(QC$all$log10_total_counts, type="lower", nmad=3)
  low.genes <- isOutlier(QC$all$log10_total_features_by_counts, type="lower", nmad=3)
  data.frame(LowLib=sum(low.lib), LowNgenes=sum(low.genes))
  
  discard <- low.lib | low.genes 
  sce <- sce[,!discard]
  summary(discard)
  # 
  
  cluster_compute <- function(sce){
    clusters <- quickCluster(sce, min.mean=0.1)
    table(clusters)
    sce <- computeSumFactors(sce, min.mean=0.1, clusters=clusters)    
    return(sce)
  }
  
  # if(class(try(cluster_compute(sce), silent = TRUE)) == "try-error"){
  #   sce <- computeSumFactors(sce, min.mean=0.1)
  # }else{
  #   sce <- cluster_compute(sce)
  # }
  
  sce <- computeSumFactors(sce, min.mean=0.1)

  summary(sizeFactors(sce))
  sce <- normalize(sce)
  
  fit <- trendVar(sce, parametric=TRUE, use.spikes=FALSE) 
  dec <- decomposeVar(sce, fit)
  # plot(dec$mean, dec$total, xlab="Mean log-expression", 
  #     ylab="Variance of log-expression", pch=16)
  # curve(fit$trend(x), col="dodgerblue", add=TRUE)
  
  dec$Symbol <- rowData(sce)$rownames.counts.
  dec <- dec[order(dec$bio, decreasing=TRUE),]
  head(dec)
    
  return(list("sce" = sce, "dec" = dec))
}

plotly_3d_pca_by_feature <- function(feature = "RXRG", msce, format, title, color, color_var = F, org = "human"){
	
  title = paste0(title, " expression of ", feature)
  
  if(!feature %in% rownames(msce)){
  	warning(paste0(feature, " missing from data"))
  	return(NULL)
  }
  msce <- msce[rownames(msce) %in% feature,]

  df <- as.tibble(reducedDim(msce, format), rownames = "cell_id")
  
  gene_exp <- tidyr::gather(as.tibble(logcounts(msce)), key = "cell_id", value = !!feature)
  
  df <- as.tibble(reducedDim(msce, format), rownames = "cell_id") %>% 
    dplyr::left_join(gene_exp, by = "cell_id")

  if (color_var == T){
    color_var = levels(df[[color]])
  } else {
    color_var = c('#BF382A', '#0C4B8E', '#2ab0bf')
  }
  
  p <- plot_ly(df, x = ~df[[2]], y = ~df[[3]], z = ~df[[4]], color = ~df[[feature]], colors = color_var, text = ~paste('cell id:', cell_id)) %>%
    add_markers(size = 1) %>%
    layout(title = title,
           scene = list(xaxis = list(title = 'dim 1'),
                       yaxis = list(title = 'dim 2'),
                       zaxis = list(title = 'dim 3')))
  return(p)
}


plotly_3d_pca_by_var <- function(msce, format, title, color, color_var = F){
 # 
  df <- as.tibble(reducedDim(msce, format), rownames = "cell_id")
  df <- dplyr::left_join(df, data.frame(colData(msce)), by = c("cell_id" = "Sample_ID"))
  df[[color]] <- as.factor(df[[color]])

  if (color_var == T){
    color_var = levels(df[[color]])
  } else {
    color_var = c('#BF382A', '#0C4B8E', '#2ab0bf')
  }
  
  p <- plot_ly(df, x = ~df[[2]], y = ~df[[3]], z = ~df[[4]], color = ~df[[color]], colors = color_var, text = ~paste('cell id:', cell_id)) %>%
    add_markers(size = 1) %>%
    layout(title = title,
           scene = list(xaxis = list(title = 'dim 1'),
                       yaxis = list(title = 'dim 2'),
                       zaxis = list(title = 'dim 3')))
  return(p)
}

prep_sce <- function(sce){
  
  sce <- calculateQCMetrics(sce, compact=TRUE)
  QC <- sce$scater_qc
  low.lib <- isOutlier(QC$all$log10_total_counts, type="lower", nmad=3)
  low.genes <- isOutlier(QC$all$log10_total_features_by_counts, type="lower", nmad=3)
  data.frame(LowLib=sum(low.lib), LowNgenes=sum(low.genes))
  
  discard <- low.lib | low.genes 
  sce <- sce[,!discard]
  summary(discard)
  # 
  summary(sizeFactors(sce))
  sce <- normalize(sce)
}

run_census <- function(sce, census_output_file){
	# 
	
	# create new celldataset
	pd <- new("AnnotatedDataFrame", data=data.frame(colData(sce)))
	fd <- new("AnnotatedDataFrame", data=data.frame(rowData(sce)))
	
	
	HSMM <- newCellDataSet(assays(sce)[["abundance"]],
												 phenoData = pd,
												 featureData = fd,
												 lowerDetectionLimit=0.1,
												 expressionFamily=tobit(Lower=0.1))

	HSMM_path <- gsub("census_matrix.csv", "raw_dataset.rds", census_output_file)
	
	# saveRDS(HSMM, HSMM_path)
	
	OnlyZeros = (colSums(Biobase::exprs(HSMM))==0)
	paste(sum(OnlyZeros), "cells have zero reads in total")
	
	Valid = which(!OnlyZeros)
	
	HSMM <- HSMM[,Valid]
	
	rpc_matrix <- monocle::relative2abs(HSMM, method = "num_genes")

	pd <- pd[Valid,]
	
	# Now, make a new CellDataSet using the RNA counts
	HSMM <- newCellDataSet(as(rpc_matrix, "sparseMatrix"),
												 phenoData = pd,
												 featureData = fd,
												 lowerDetectionLimit=1,
												 expressionFamily=negbinomial.size())
	
	
	# HSMM <- estimateSizeFactors(HSMM)
	# HSMM <- estimateDispersions(HSMM)
	
	
	#print output of census to csv prior to monocle workflow
	
	# write.csv(as.matrix(Biobase::exprs(HSMM)), census_output_file)
	
	census_meta_file <- gsub("census_matrix.csv", "census_meta.csv", census_output_file)

	# write.csv(pData(HSMM), census_meta_file, row.names = FALSE)
	
	return(as.matrix(Biobase::exprs(HSMM)))

}

prep_batches <- function(sce){
  # 

  sce <- calculateQCMetrics(sce, compact=TRUE)
  QC <- sce$scater_qc
  low.lib <- isOutlier(QC$all$log10_total_counts, type="lower", nmad=3)
  low.genes <- isOutlier(QC$all$log10_total_features_by_counts, type="lower", nmad=3)
  data.frame(LowLib=sum(low.lib), LowNgenes=sum(low.genes))
  
  discard <- low.lib | low.genes 
  sce <- sce[,!discard]
  summary(discard)
  # 
  
  cluster_compute <- function(sce){
    clusters <- quickCluster(sce, min.mean=0.1)
    table(clusters)
    sce <- computeSumFactors(sce, min.mean=0.1, clusters=clusters)    
    return(sce)
  }
  
  if(class(try(cluster_compute(sce), silent = TRUE)) == "try-error"){
    sce <- computeSumFactors(sce, min.mean=0.1)
  }else{
    sce <- cluster_compute(sce)
  }
  
  sce <- computeSumFactors(sce, min.mean=0.1)

  summary(sizeFactors(sce))
  sce <- normalize(sce)
  
  fit <- trendVar(sce, parametric=TRUE, use.spikes=FALSE) 
  dec <- decomposeVar(sce, fit)
  # plot(dec$mean, dec$total, xlab="Mean log-expression", 
  #     ylab="Variance of log-expression", pch=16)
  # curve(fit$trend(x), col="dodgerblue", add=TRUE)
  
  dec$Symbol <- rowData(sce)$rownames.counts.
  dec <- dec[order(dec$bio, decreasing=TRUE),]
  head(dec)
    
  return(list("sce" = sce, "dec" = dec))
}

lookup_refseq_from_symbol <- function(gene){
  #
  table <- AnnotationDbi::select(org.Mm.eg.db, keys=gene, columns = c("SYMBOL","UNIGENE", "REFSEQ"), keytype = "SYMBOL")
  return(table)
}

lookup_entrez_from_symbol <- function(gene){
  #
  table <- AnnotationDbi::select(org.Mm.eg.db, keys=gene, columns = c("SYMBOL","UNIGENE", "ENTREZID"), keytype = "SYMBOL")
  return(table)
}

lookup_enst_from_symbol <- function(gene){
  # 
  enst <- dplyr::filter(grch38, symbol == gene) %>% 
		dplyr::left_join(grch38_tx2gene, by = "ensgene") %>% 
		dplyr::pull("enstxp")
  return(enst)
}

```


```{r}

features = c("gene", "transcript")

sce_paths <- fs::path(proj_dir, "output", "sce") %>% 
	fs::dir_ls() %>% 
	fs::path_filter(glob = "*.rds")

feature_sces <- purrr::map(sce_paths, readRDS)
```


```{r}

census_counts <- purrr::map(feature_sces, run_census)

```



```{r}

feature_sces <- purrr::map2(feature_sces, census_counts, append_census_counts)

sce_paths <- fs::path(proj_dir, "output", "sce", paste0(features, "_sce_with_census.rds"))

purrr::map2(feature_sces, sce_paths, saveRDS)

```

```{r}

norm_feature_sces <- purrr::map(feature_sces, prep_batches)
names(norm_feature_sces) <- features

norm_sce_paths <- fs::path(proj_dir, "output", "sce", paste0(features, "_sce_normalized.rds"))

purrr::map2(norm_feature_sces, norm_sce_paths, saveRDS)


```

```{r}
features <- c("gene", "transcript")
norm_sce_paths <- paste0(proj_dir, "/output/sce/", features, "_sce_normalized.rds")

norm_feature_sces <- lapply(norm_sce_paths, readRDS)
names(norm_feature_sces) <- features

gene_norm_sce <- norm_feature_sces$gene$sce

transcript_norm_sce <- norm_feature_sces$transcript$sce

```

# run pca and tsne for genes

```{r}
sce <- norm_feature_sces$gene$sce

set.seed(100)
# Using irlba to set up the t-SNE, for speed.

dimred_counts <- runPCA(sce, ntop=Inf, method="prcomp", ncomponents = 3)
dimred_census <- runPCA(sce, ntop=Inf, method="prcomp", ncomponents = 3, exprs_values = "census_counts")


# plot original tSNE
dimred_counts <- runTSNE(dimred_counts, use_dimred="PCA", ncomponents = 3)
# counts_tsne_plot <- plotTSNE(dimred_counts, colour_by="seq_type") + ggtitle("tSNE Original")

```

# run plotly for 3d pcas genes

```{r}

plotly_3d_pca_by_var(dimred_counts, "PCA", "Raw Counts PCA colored by batch", color="batch")
plotly_3d_pca_by_var(dimred_census, "PCA", "Census Counts PCA colored by batch", color="batch")

plotly_3d_pca_by_feature("RXRG", dimred_counts, "PCA", "test")


```


# run pca and tsne for transcripts

```{r}

sce <- norm_feature_sces$transcript$sce

set.seed(100)
# Using irlba to set up the t-SNE, for speed.

dimred_counts <- runPCA(sce, ntop=Inf, method="prcomp", ncomponents = 3)
dimred_census <- runPCA(sce, ntop=Inf, method="prcomp", ncomponents = 3, exprs_values = "census_counts")


# plot original tSNE
dimred_counts <- runTSNE(dimred_counts, use_dimred="PCA", ncomponents = 3)
counts_tsne_plot <- plotTSNE(dimred_counts, colour_by="batch") + ggtitle("tSNE Original")

```

# run plotly for 3d pcas transcripts

```{r}

plotly_3d_pca_by_var(dimred_counts, "PCA", "Raw Counts PCA colored by batch", color="batch")
plotly_3d_pca_by_var(dimred_census, "PCA", "Census Counts PCA colored by batch", color="batch")

rxrg_trx <- lookup_enst_from_symbol("RXRG")

purrr::map(rxrg_trx, plotly_3d_pca_by_feature, dimred_counts, "PCA", "Raw Counts colored by")



```


