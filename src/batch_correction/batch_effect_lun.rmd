---
title: "batch_effect_lun.rmd"
author: "Kevin Stachelek"
date: "8/22/2018"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.width=14, fig.height=10)
```

```{r}

# load optparse -----------------------------------------------------------
library(optparse)

# handle command line options ---------------------------------------------

#default input files -----------------------------------------------------

#SHL
# default_expression_files = "~/single_cell_pipeline/output/FACS_20170407_sunlee_H_sapiens_output/Sunhye_stringtie.tpm.csv:~/single_cell_pipeline/output/FACS_20171031_sunlee_H_sapiens_output/transcripts.tpm.csv"
# default_cell_info = "~/single_cell_pipeline/output/FACS_20170407_sunlee_H_sapiens_output/Sunhye_cell_division_day_treatment.csv:~/single_cell_pipeline/data/sc_cone_devel/sc_cone_devel_H_sapiens/FACS_20171031_sunlee_H_sapiens/FACS_20171031_sunlee_sample_sheet.csv"
# default_out = "~/single_cell_pipeline/output/merged_analyses/FACS_20170407_sunlee_FACS_20171031_sunlee_singlecellexperiment2.rds"
# default_tags = "exp1_,exp2_"

#DS 20181001
# default_expression_files = "~/single_cell_projects/quicklinks/FACS_20170407_dshayler_H_sapiens_proj/output/stringtie_transcripts_raw_counts.csv,~/single_cell_projects/quicklinks/FACS_20171031_dshayler_H_sapiens_proj/output/stringtie_transcripts_raw_counts.csv"
# default_cell_info = "~/single_cell_projects/quicklinks/FACS_20170407_dshayler_H_sapiens_proj/Dominic_Cell_Age_and_Sort_Method_042017.csv,~/single_cell_projects/quicklinks/FACS_20171031_dshayler_H_sapiens_proj/FACS_20171031_dshayler_sample_sheet.csv"
# default_out = "~/single_cell_projects/quicklinks/FACS_20170407_20171031_dshayler_H_sapiens_merge_proj/output/FACS_20170407_20171031_dshayler_mnncorrect.rds"
# default_tags = ","

#DS 3_seq
default_expression_files = "~/single_cell_projects/quicklinks/3_seq_dshayler_proj/output/All_cells_stringtie_genes_raw_counts_merged.csv"
default_cell_info = "~/single_cell_projects/quicklinks/3_seq_dshayler_proj/output/FACS_20170407_20171031_20181001_dshayler_all_cells_census_meta.csv"
default_out = "~/single_cell_projects/quicklinks/3_seq_dshayler_proj/output/differential_expression/"
default_tags = ","

default_cell_settings <- "~/single_cell_tools/dshayler_input/2_seq_3dformat_050418.csv"
default_plot_settings <- "~/single_cell_tools/dshayler_input/072018_3d_PCA_No_Bad_Reads_NoVSX_Color_by_Seq.txt"


#'  section for parsing command line options when calling script
#'  ###################################
option_list = list(
  make_option(c("-e", "--gene_expression_files"), type="character", default=default_expression_files,
              help="colon separated list of gene expression input filenames [default= %default]", metavar="character"),
  make_option(c("-c", "--cell_info"), type="character", default=default_cell_info,
              help="colon separated list of cell metadata filenames [default= %default]", metavar="character"),
  make_option(c("-t", "--exp_tags"), type="character", default=default_tags,
              help="colon separated list of experiment tags (ex. DS_:SHL_) [default= %default]", metavar="character"),
  make_option(c("-s", "--cellset"), type="character", default=default_cell_settings,
              help="tab delimited cell settings file [default= %default]", metavar="character"),
  make_option(c("-p", "--plot_settings"), type="character", default=default_plot_settings,
              help="tab delimited plot settings file [default= %default]", metavar="character"),
  make_option(c("-o", "--outfile"), type="character", default=default_out,
              help="output_file for merged singlecellexperiment [default= %default]", metavar="character")
);

opt_parser = OptionParser(option_list=option_list);
opt = parse_args(opt_parser, print_help_and_exit = TRUE);

if (any(sapply(opt, is.na))){
  print_help(opt_parser)
  stop("Please provide all necessary arguments.", call.=FALSE)
}


```

```{r, message = FALSE}

# load required libraries -------------------------------------------------
library(ggplot2)
library(reshape2)
library(gtools)
library(tidyverse)
library(SingleCellExperiment)
library(scran)
library(scater)
library(org.Hs.eg.db)
library(plotly)
```

```{r}

# load required functions -------------------------------------------------

## parse martin metadata
find_remove_cells <- function(plot_settings, annotation){
  # browser()
  test <- readLines(plot_settings)
  
  if (!any(grepl('remove', test))){
    return(NULL)
  }
  
  vecs <- list()
  mtnames <- c()
  for (i in test){
    if (!grepl("#", i) & grepl('remove', i)){
      lbline = strsplit(i, "\t")
      d = unlist(lbline)[[2]]
      vecs <- append(vecs, lbline)
      mtnames <- append(mtnames, d)    
    }
  }
  
  pfx <- tolower(gsub("_.*", "", mtnames))
  valid_pfx  <- which(pfx %in% colnames(annotation))
  
  if (length(valid_pfx) == 0){
    return(NULL)
  }
  
  pfx <- pfx[valid_pfx]
  
  
  
  sfx <- gsub(".*_", "", mtnames[valid_pfx])
  
  remove_cells <- purrr::map2(pfx, sfx , function(x, y) annotation[annotation[tolower(x)] == y,])
  
  
  
  remove_cells <- dplyr::bind_rows(remove_cells)
  
  ind <- apply(remove_cells, 1, function(x) all(is.na(x)))
  remove_cells <- remove_cells[ !ind, ]
  
  remove_cells <- unique(remove_cells[,1])
  
}


match_cols <- function(match_vecs, sv_name){
  out=NULL
  for (i in match_vecs){
    vetor <- i
    vetor <- vetor[vetor != ""]
    key <- data.frame(sample_id=vetor[-1], sv_name=rep(gsub(".*_","", vetor[[1]]), (length(vetor)-1)))  
    out <- rbind(out, key)
  }  
  colnames(out) <- c("sample_id", sv_name) 
  return(out)
}

convert_mt_setting <- function(cell_settings, plot_settings){
  
  test <- readLines(cell_settings)
  
  vecs <- list()
  mtnames <- c()
  for (i in test){
    if (!grepl("#", i)){
      lbline = strsplit(i, "\t")
      d = unlist(lbline)[[1]]
      vecs <- append(vecs, lbline)
      mtnames <- append(mtnames, d)    
    }
    
  }
  
  pfx <- unique(gsub("_.*", "", mtnames[grep("_", mtnames)]))
  pfx <- paste0(pfx, "_")
  test <- list()
  for (i in pfx){
    test1 <- list(which(startsWith(mtnames, i)))
    names(test1) = tolower(gsub("_", "", i))
    test <- append(test, test1)
  }
  
  sub_vecs <- list()
  vec_names <- list()
  for (i in test){
    test_vec <- vecs[i]
    sub_vecs <- append(sub_vecs, list(test_vec))
  }
  
  # names(sub_vecs) <- vec_names[1:length(sub_vecs)]
  names(sub_vecs) <- names(test)
  
  sub_vecs <- sub_vecs[unlist(lapply(sub_vecs, length) != 0)]
  
  param_dfs <- purrr::map2(sub_vecs, names(sub_vecs), match_cols)
  
  
  
  if (is.list(param_dfs) & length(param_dfs) != 0) {
    param_dfs <- param_dfs %>%
      Reduce(function(dtf1,dtf2) dplyr::full_join(dtf1,dtf2,by="sample_id"), .) %>% 
      dplyr::arrange(sample_id)  
    
    dup_cells <- which(duplicated(param_dfs[,1]))
    if (any(dup_cells)){
      print(paste0("cells ", paste(param_dfs$sample_id[dup_cells], collapse = " "), " found duplicated in cell sets! They will be removed from analysis"))
      param_dfs <- param_dfs[-dup_cells,]
    }
    
    rownames(param_dfs) <- param_dfs[,1]
    
  }
  
  remove_cells <- find_remove_cells(plot_settings, param_dfs)
  
  
  return(list("annotation" = param_dfs, "removed_cells" = remove_cells))
  
}

check_rownames <- function(counts){
  if(grepl("ENST.*", rownames(counts))){
    rownames(counts) <- rownames(counts)
  } else{
    rownames(counts) <- counts[,1]
    counts[,1] <- NULL
  } 
  return(counts)
}

data_append_exp_tag <- function(df, exp_tag){
  names(df) <- paste0(exp_tag, names(df))
  return(df)
}

meta_append_exp_tag <- function(df, exp_tag){
  names(df)[1] <- "sample_id"
  df <- dplyr::mutate(df, sample_id = paste0(exp_tag, sample_id))
  return(df)
}

batch_correct <- function(counts, colData, rmc){
  # browser()
  sce <- SingleCellExperiment(list(counts=as.matrix(counts)), 
                              colData=colData,
                              rowData=DataFrame(rownames(counts)))
  
  # remove martin cells
  kept_samples <- (!colnames(sce) %in% rmc)
  sce <- sce[,kept_samples]
  
  
  sce <- calculateQCMetrics(sce, compact=TRUE)
  QC <- sce$scater_qc
  low.lib <- isOutlier(QC$all$log10_total_counts, type="lower", nmad=3)
  low.genes <- isOutlier(QC$all$log10_total_features_by_counts, type="lower", nmad=3)
  data.frame(LowLib=sum(low.lib), LowNgenes=sum(low.genes))
  
  discard <- low.lib | low.genes 
  sce <- sce[,!discard]
  summary(discard)
  # browser()
  
  cluster_compute <- function(sce){
    clusters <- quickCluster(sce, min.mean=0.1)
    table(clusters)
    sce <- computeSumFactors(sce, min.mean=0.1, clusters=clusters)    
    return(sce)
  }
  
  if(class(try(cluster_compute(sce), silent = TRUE)) == "try-error"){
    sce <- computeSumFactors(sce, min.mean=0.1)
  }else{
    sce <- cluster_compute(sce)
  }

  summary(sizeFactors(sce))
  sce <- normalize(sce)
  
  fit <- trendVar(sce, parametric=TRUE, use.spikes=FALSE) 
  dec <- decomposeVar(sce, fit)
  plot(dec$mean, dec$total, xlab="Mean log-expression", 
      ylab="Variance of log-expression", pch=16)
  curve(fit$trend(x), col="dodgerblue", add=TRUE)
  
  dec$Symbol <- rowData(sce)$rownames.counts.
  dec <- dec[order(dec$bio, decreasing=TRUE),]
  head(dec)
    
  return(list(sce, dec))
}

safe_read <- function(sep_file){
  L <- readLines(sep_file, n = 1)
  if (grepl("\t", L)){
    df <- read.table(sep_file, sep = "\t", header = TRUE) 
    rownames(df) <- df[,1]
    return(df)
  } else {
    df <- read.csv(sep_file, header = TRUE)
    rownames(df) <- df[,1]
    return(df)
  } 
}
  
run_plotly <- function(msce, format, title){
  df <- as.tibble(reducedDim(msce, format), rownames = "cell_id")
  df$batch = msce$Batch
  last_col <- ncol(df)
  colnames(df)[c(1,2,3,4,last_col)] <- c("cell_id", "dim 1", "dim 2", "dim 3", "batch")
  # browser()
  p <- plot_ly(df, x = ~`dim 1`, y = ~`dim 2`, z = ~`dim 3`, color = ~batch, colors = c('#BF382A', '#0C4B8E'), text = ~paste('cell id:', cell_id)) %>%
    add_markers() %>%
    layout(title = title,
           scene = list(xaxis = list(title = 'dim 1'),
                       yaxis = list(title = 'dim 2'),
                       zaxis = list(title = 'dim 3')))
  return(p)
}

```

```{r}

# load data ------------------------------------------------------

EXPRESSION_PATHS <- unlist(strsplit(opt$gene_expression_files,"[,:]"))
GROUP_PATHS = unlist(strsplit(opt$cell_info,"[,:]"))
exp_tags = unlist(strsplit(opt$exp_tags,"[,:]"))
outfile = opt$outfile

counts <- purrr::map(EXPRESSION_PATHS, safe_read)
colData <- purrr::map(GROUP_PATHS, safe_read)

# drop rownames from counts first column
counts <- lapply(counts, function(x) x[,-1])

## parse martin metadata
mt_settings <- convert_mt_setting(opt$cellset, opt$plot_settings)
rmc <- mt_settings$removed_cells

rmc2 <- read.csv("~/single_cell_pipeline/tmp/082718_current_cells_to_remove_list.csv", header = FALSE, stringsAsFactors = F)[[1]]

rmc <- union(rmc, rmc2)

# manage ds's unsafe sample names
rmc <- unlist(lapply(exp_tags, paste0, rmc))


names(counts) <- exp_tags
names(colData) <- exp_tags
counts <- purrr::map2(counts, exp_tags, data_append_exp_tag)
colData <- purrr::map2(colData, exp_tags, meta_append_exp_tag)

```


We create a SingleCellExperiment object to store the counts and metadata together. This reduces the risk of book-keeping errors in later steps of the analysis. 

```{r}

# test <- purrr::map2(counts, colData, batch_correct, rmc)

# saved after calculating dec for each count matrix 
# saveRDS(test, "~/tmp/batch_correct_test.rds")
test <- readRDS("~/tmp/batch_correct_test.rds")

sces <- sapply(test, "[", 1)

decs <- sapply(test, "[", 2)
decs_rows <- lapply(decs, rownames)
tops <- lapply(decs_rows, function(x) x[seq_len(1000)] )

chosen <- Reduce(intersect, tops)

# Adding some gene symbols for interpretation.
# symb <- mapIds(org.Hs.eg.db, keys=chosen, keytype="ENSEMBL", column="SYMBOL")
# DataFrame(ID=chosen, Symbol=symb)

# Identifying genes that are annotated in all batches.
in.all <- Reduce(intersect, decs_rows)

decs_all <- lapply(decs, function(x) x[in.all,])

# Setting weighted=FALSE so each batch contributes equally.
combined <- do.call(combineVar, c(decs_all, weighted=FALSE))

chosen2 <- rownames(combined)[head(order(combined$bio, decreasing=TRUE), 1000)]


```


# 4 Performing MNN-based correction

```{r}
set.seed(100)
original <- sapply(sces, function(x) logcounts(x)[chosen,])
names(original) <- gsub("_d.*", "", sapply(strsplit(EXPRESSION_PATHS, "/"), "[", 4))

mnn.out <- do.call(fastMNN, c(original, list(k=20, d=50, approximate=TRUE)))
dim(mnn.out$corrected)

mnn.out$batch
mnn.out$pairs
  
```


# 5 Examining the effect of correction

```{r}
omat <- do.call(cbind, original)

sce <- SingleCellExperiment(list(logcounts=omat))
reducedDim(sce, "MNN") <- mnn.out$corrected
sce$Batch <- as.character(mnn.out$batch)
sce

```

```{r}

set.seed(100)
# Using irlba to set up the t-SNE, for speed.
osce <- runPCA(sce, ntop=Inf, method="prcomp", ncomponents = 3)
op <- plotPCA(osce, colour_by='Batch') + ggtitle('PCA Original')
osce <- runTSNE(osce, use_dimred="PCA", ncomponents = 3)
ot <- plotTSNE(osce, colour_by="Batch") + ggtitle("tSNE Original")

set.seed(100)

cp <- plotReducedDim(sce, use_dimred = "MNN", colour_by = "Batch") + ggtitle("PCA Corrected")

csce <- runTSNE(sce, use_dimred="MNN", ncomponents = 3)
ct <- plotTSNE(csce, colour_by="Batch") + ggtitle("tSNE Corrected")

run_plotly(osce, "PCA", "Original PCA")
run_plotly(sce, "MNN", "Corrected PCA")

run_plotly(osce, "TSNE", "Original tSNE")
run_plotly(csce, "TSNE", "Corrected tSNE")

multiplot(op, cp, cols=2)
multiplot(ot, ct, cols=2)

```

```{r plot_dendrogram, include = F}

library(ggplot2)
library(ggdendro)
library(dendextend)
library(plotly)

newggplot.ggdend <- function (data, segments = TRUE, labels = TRUE, nodes = TRUE, 
          horiz = FALSE, theme = theme_dendro(), offset_labels = 0, ...) {
  data <- prepare.ggdend(data)
  #angle <- ifelse(horiz, 0, 90)
  #hjust <- ifelse(horiz, 0, 1)
  p <- ggplot()
  if (segments) {
    p <- p + geom_segment(data = data$segments, aes_string(x = "x", y = "y", xend = "xend", yend = "yend", colour = "col", linetype = "lty", size = "lwd"), lineend = "square") + 
      guides(linetype = FALSE, col = FALSE) + scale_colour_identity() + 
      scale_size_identity() + scale_linetype_identity()
  }
  if (nodes) {
    p <- p + geom_point(data = data$nodes, aes_string(x = "x", y = "y", colour = "col", shape = "pch", size = "cex")) + 
      guides(shape = FALSE, col = FALSE, size = FALSE) + 
      scale_shape_identity()
  }
  if (labels) {
    data$labels$cex <- 5 * data$labels$cex
    data$labels$y <- data$labels$y + offset_labels
    p <- p + geom_text(data = data$labels, aes_string(x = "x", y = "y", label = "label", colour = "col", size = "cex", angle = "angle", hjust = "hjust", vjust = "vjust"))#edited
  }
  if (horiz) {
    p <- p + coord_flip() + scale_y_reverse(expand = c(0.2, 0))
  }
  if (!is.null(theme)) {
    p <- p + theme
  }
  p
}

assignInNamespace(x = "ggplot.ggdend", ns = "dendextend", value = newggplot.ggdend)

```

```{r}

#dendogram data
x <- as.matrix(scale(assay(osce)))

dd.row <- x %>% 
	t %>% 
	dist %>% 
	hclust %>% 
	as.dendrogram %>%
	set("branches_k_color", k=3) %>% 
	color_labels(k = 3) %>% 
	set("branches_lwd", c(0.4)) %>%
	# set("branches_lty", c(1,1,3,1,1,2)) %>%
	# set("labels_colors") %>%
	set("labels_cex", c(.9)) %>%
	set("leaves_pch", 19) %>%
	set("leaves_cex", 2) %>%
	# set("nodes_col", c("orange", "black", "plum", NA)) %>%
	identity()


dd.col <- x %>% 
	dist %>% 
	hclust %>% 
	as.dendrogram %>%
	set("branches_k_color", k=3) %>% 
	color_labels(k = 3) %>% 
	set("branches_lwd", c(0.4)) %>%
	# set("branches_lty", c(1,1,3,1,1,2)) %>%
	set("labels_colors") %>%
	set("labels_cex", c(.9)) %>%
	set("nodes_pch", 26) %>%
	# set("nodes_col", c("orange", "black", "plum", NA)) %>%
	identity()

gdrow <- as.ggdend(dd.row)
gdrow$labels$angle <- 0
gdrow$labels$vjust <- cos(gdrow$labels$angle * pi) / (180)
gdrow$labels$hjust <- sin(gdrow$labels$angle * pi) / (180)

gdrow$labels$y = -1

gdcol <- as.ggdend(dd.col)

# the nodes are not implemented yet.
gdr <- ggplot(gdrow) + 
	NULL

# reproducing the above plot in ggplot2 :)
gdc <- ggplot(gdcol)

ggplotly(gdr)

# ggplotly(gdc)

```





# 6 Using the corrected values in downstream analyses

```{r, include=FALSE}
snn.gr <- buildSNNGraph(sce, use.dimred="MNN")
clusters <- igraph::cluster_walktrap(snn.gr)
table(clusters$membership, sce$Batch)

csce$Cluster <- factor(clusters$membership)
cp <- plotTSNE(csce, colour_by="Cluster") + ggtitle("Cluster")
bp <- plotTSNE(csce, colour_by="Batch") + ggtitle("Batch")

multiplot(cp, bp, cols=2)
```



